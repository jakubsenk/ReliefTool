@using ReliefWeb.Models
@model List<ReliefResult>
@{
	ViewBag.Title = "Relief";
}

<h2>Result</h2>
<style>
	td, th {
		padding: 3px 5px;
		min-width: 150px;
	}

	th {
		cursor: pointer;
	}
</style>
@if (Model != null && Model.Count > 0)
{
	<table border="1" style="display: inline-table">
		<thead>
			<tr>
				<th>Algorithm</th>
				<th>Best column</th>
				<th>Calculation time</th>
			</tr>
		</thead>
		<tbody>
			@foreach (ReliefResult item in Model)
			{
				<tr>
					<td>@item.Name</td>
					<td>@item.BestScore.Key</td>
					<td>@item.Duration (@item.Duration.TotalMilliseconds)</td>
				</tr>
			}
		</tbody>
	</table>
	<br />
	<br />
	<table id="result-table" border="1" style="display: inline-table">
		<thead>
			<tr>
				<th style="cursor: initial">Column</th>
				@for (int i = 0; i < Model.Count; i++)
				{
					<th colspan="2" style="text-align: center" onclick="sortTable(@(i + 1))">@Model[i].Name</th>
				}
			</tr>
		</thead>
		<tbody>
			@for (int i = 0; i < Model[0].Scores.Count; i++)
			{
				<tr data-sortable>
					<td>@Model[0].Scores[i].Key</td>
					@for (int j = 0; j < Model.Count; j++)
					{
						if (Model[j].BestScore.Key == Model[j].Scores[i].Key)
						{
							<td style="text-align: center" colspan="2"><b>@Model[j].Scores[i].Value.ToString("N5")</b></td>
						}
						else
						{
							<td style="text-align: center" colspan="2">@Model[j].Scores[i].Value.ToString("N5")</td>
						}
					}
				</tr>
			}
			@if (Model[0].RemovedCount != null)
			{
				<tr>
					<td colspan="2">+@Model[0].RemovedCount.Value removed columns</td>
				</tr>
			}


			@if (Model[0].Clusters != null)
			{
				<tr>
					<td></td>
					@for (int i = 0; i < Model.Count; i++)
					{
						<td style="width: 200px">
							@for (int j = 0; j < Model[i].Sillhoutte.ClusterPairs.Count; j++)
							{
								@Html.Partial("BarChart", Model[i].Sillhoutte.ClusterPairs[j], new ViewDataDictionary() { { "id", "chart_sil_" + i + "_" + j }, { "color", Model[i].Sillhoutte.ClusterColors[j] } })
							}
						</td>

						<td style="width: 200px">
							@for (int j = 0; j < Model[i].SillhoutteAll.ClusterPairs.Count; j++)
							{
								@Html.Partial("BarChart", Model[i].SillhoutteAll.ClusterPairs[j], new ViewDataDictionary() { { "id", "chart_sil_all_" + i + "_" + j }, { "color", Model[i].SillhoutteAll.ClusterColors[j] } })
							}
						</td>
					}
				</tr>
				for (int j = 0; j < Model[0].Graphs.Count; j++)
				{
					<tr>
						<td></td>

						@for (int i = 0; i < Model.Count; i++)
						{
							<td>
								@Html.Partial("Chart", Model[i].Graphs[j], new ViewDataDictionary() { { "id", "chart_" + i + "_" + j } })
							</td>
							<td>
								@Html.Partial("Chart", Model[i].GraphsAll[j], new ViewDataDictionary() { { "id", "chart_" + i + "_" + j + "_o" } })
							</td>
						}
					</tr>
				}
			}
		</tbody>
	</table>
	<br />
	<br />
	<button onclick="location.href = '/Home/Export'">Get PDF</button>
}

<script>
	function sortTable(n, e) {
		var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
		table = document.getElementById("result-table");
		switching = true;
		// Set the sorting direction to ascending:
		dir = "desc";
		/* Make a loop that will continue until
		no switching has been done: */
		while (switching) {
			// Start by saying: no switching is done:
			switching = false;
			rows = [...table.rows].filter(r => r.attributes["data-sortable"]);
			/* Loop through all table rows (except the
			first, which contains table headers): */
			for (i = 0; i < (rows.length - 1); i++) {
				// Start by saying there should be no switching:
				shouldSwitch = false;
				/* Get the two elements you want to compare,
				one from current row and one from the next: */
				x = rows[i].getElementsByTagName("TD")[n];
				y = rows[i + 1].getElementsByTagName("TD")[n];
				/* Check if the two rows should switch place,
				based on the direction, asc or desc: */
				if (dir == "asc") {
					if (Number(x.innerHTML.replace(",", ".").replace("<b>", "").replace("</b>", "")) > Number(y.innerHTML.replace(",", ".").replace("<b>", "").replace("</b>", ""))) {
						// If so, mark as a switch and break the loop:
						shouldSwitch = true;
						break;
					}
				} else if (dir == "desc") {
					if (Number(x.innerHTML.replace(",", ".").replace("<b>", "").replace("</b>", "")) < Number(y.innerHTML.replace(",", ".").replace("<b>", "").replace("</b>", ""))) {
						// If so, mark as a switch and break the loop:
						shouldSwitch = true;
						break;
					}
				}
			}
			if (shouldSwitch) {
				/* If a switch has been marked, make the switch
				and mark that a switch has been done: */
				rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
				switching = true;
				// Each time a switch is done, increase this count by 1:
				switchcount++;
			} else {
				/* If no switching has been done AND the direction is "asc",
				set the direction to "desc" and run the while loop again. */
				if (switchcount == 0 && dir == "asc") {
					dir = "desc";
					switching = true;
				}
			}
		}
	}
</script>